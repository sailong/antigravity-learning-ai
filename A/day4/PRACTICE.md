# Day 4 知识大地图：从“野路子”到“正规军”

## 🧠 核心心法：为什么要用 MCP？

在 Day 3，我们的函数定义和 AI 是**强耦合**的。代码写在哪，函数就得在哪。
在 Day 4，我们引入了 **MCP (Model Context Protocol)**，它实现了：
- **解耦**：Server（工具提供方）和 Client（决策方）可以分开运行在不同的进程甚至服务器上。
- **标准化**：不用再手动写繁琐的 `tools = [...]` JSON 描述了，只要写好 Python 函数，协议自动帮你转换。

---

## 🛠️ 技术哨口：FastMCP 的三板斧

### 1. 身份标记：`mcp = FastMCP("Name")`
这是 Server 的身份证。一个 Server 可以包含几十个工具，它们都属于这个“名字”名下。

### 2. 工具声明：`@mcp.tool()`
这是最神奇的地方。它利用了 Python 的 **Introspection（自省）** 机制：
- **函数名** → 工具名
- **Docstring** → 工具说明（AI 靠这个判断要不要用它）
- **类型提示 (typing)** → AI 的输入规范（JSON Schema）

### 3. 类型约束：`arg: int`
**重点：** 在 MCP 中，类型注解不是可选的，而是**必需**的。如果你不写类型，AI 就不知道该传字符串还是数字，连接就会报错。

---

## 🔒 生产环境避坑指南

### 1. 路径穿越攻击 (Path Traversal)
写文件系统 Server 时，最忌讳 AI 诱导你读取系统密码文件（如 `/etc/passwd`）。
- **巩固点：** 永远使用 `Path(path).resolve()` 来校验路径，确保它在你的工作目录内。

### 2. 异常即协议
在 FastMCP 装饰的函数里，你抛出的 `raise FileNotFoundError` 会被自动包装成标准的 MCP Error 发送给 AI。
- **巩固点：** 不要害怕抛出异常，清晰的报错是给 AI 最好的反馈，它甚至会根据报错自己纠错。

### 3. 截断机制 (Truncation)
AI 的“胃口”（上下文窗口）有限。
- **巩固点：** 读取文件时，一定要像我们在 `read_file` 里做的那样，设置 `max_lines`，防止超大文件把 AI 的“大脑”撑爆。

---

## ⚖️ 毕业考试：Day 3 vs Day 4

| 维度 | Day 3 (手动版) | Day 4 (MCP 版) |
| :--- | :--- | :--- |
| **工具描述** | 手写百行 JSON，极易出错 | 自动生成，只要写好 Python 注释 |
| **可复用性** | 只能在这个脚本里用 | 任何支持 MCP 的 Client（如 Claude Desktop）都能一键连接 |
| **扩展性** | 每加一个函数都要改多处代码 | 只需加一行装饰器 |
| **定位** | 个人练习/简单脚本 | 工业级/全栈 Agent 系统 |

---

## ✅ 晚安自查清单
- [ ] 我知道为什么 `mcp.tool()` 下面的函数必须写类型注解 (type hint)。
- [ ] 我理解了 AI 是通过函数的 `docstring` 来理解工具用途的。
- [ ] 我能区分什么是 Server（提供能力的）和 Client（下达指令的）。

---

**今晚好好休息，大脑会在睡眠中帮你自动整理这些逻辑。明天见！🏃‍♂️💤**
